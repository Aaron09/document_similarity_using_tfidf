uses algorithm disambiguation




flow chart algorithm euclids algorithm calculating greatest common divisor numbers locations named algorithm proceeds successive subtractions loops test yields true accurately number location greater equal number location algorithm specifies meaning number replaces similarly process terminates contents yielding algorithm derived scott 200913 symbols drawing style tausworthe 1977


mathematics computer science algorithm ˈælɡərɪðəm listen algəridhəm unambiguous specification solve class problems algorithms perform calculation data processing automated reasoning tasks
algorithm effective method expressed within finite amount space time1 welldefined formal language2 calculating function3 starting initial state initial input perhaps empty4 instructions describe computation executed proceeds finite5 number welldefined successive states eventually producing output6 terminating final ending state transition state next necessarily deterministic algorithms known randomized algorithms incorporate random input7
concept algorithm existed centuries however partial formalization would become modern algorithm began attempts solve entscheidungsproblem decision problem posed david hilbert 1928 subsequent formalizations framed attempts define effective calculability8 effective method9 formalizations included gödel–herbrand–kleene recursive functions 1930 1934 1935 alonzo churchs lambda calculus 1936 emil posts formulation 1936 alan turings turing machines 1936–7 1939 giving formal definition algorithms corresponding intuitive notion remains challenging problem10



contents


etymology
informal definition
formalization

expressing algorithms


implementation
computer algorithms
examples

algorithm example
euclids algorithm

computer language euclids algorithm
inelegant program euclids algorithm
elegant program euclids algorithm


testing euclid algorithms
measuring improving euclid algorithms


algorithmic analysis

formal versus empirical
execution efficiency


classification

implementation
design paradigm
optimization problems
field study
complexity


continuous algorithms
legal issues
history development notion algorithm

ancient near east
discrete distinguishable symbols
manipulation symbols place holders numbers algebra
mechanical contrivances discrete states
mathematics 19th century mid20th century
emil post 1936 alan turing 1936–37 1939
rosser 1939 kleene 1943
history 1950


also
notes
references
bibliography
secondary references
reading
external links



etymologyedit
word algorithm combination latin word algorismus named alkhwarizmi1112 greek word arithmos αριθμός meaning number
alkhwārizmī persian خوارزمی‎ 780–850 persian mathematician astronomer geographer scholar house wisdom baghdad whose name means native khwarezm region part greater iran uzbekistan1314 wrote treatise arabic language translated latin 12th century title algoritmi numero indorum title means algoritmi numbers indians algoritmi translators latinization alkhwarizmis name15 alkhwarizmi widely read mathematician europe late middle ages primarily book algebra16 late medieval latin algorismus english algorism corruption name simply meant decimal number system 15th century influence greek word ἀριθμός number arithmetic latin word altered algorithmus corresponding english term algorithm first attested 17th century modern sense introduced 19th century17
english first used 1230 chaucer 1391 english adopted french term wasnt late 19th century algorithm took meaning modern english
another early word 1240 manual titled carmen algorismo composed alexandre villedieu begins thus

haec algorismus praesens dicitur talibus indorum fruimur quinque figuris

translates

algorism present indian figures number times five

poem hundred lines long summarizes calculating style indian dice talibus indorum hindu numerals
informal definitionedit
detailed presentation various points view definition algorithm algorithm characterizations
informal definition could rules precisely defines sequence operations18 would include computer programs including programs perform numeric calculations generally program algorithm stops eventually19
prototypical example algorithm euclidean algorithm determine maximum common divisor integers example others described flow chart example later section
boolos jeffrey 1974 1999 offer informal meaning word following quotation

human write fast enough long enough small enough† †smaller smaller without limit youd trying write molecules atoms electrons list members enumerably infinite writing names another notation humans something equally useful case certain enumerably infinite sets give explicit instructions determining member arbitrary finite instructions given quite explicitly form could followed computing machine human capable carrying elementary operations symbols20

enumerably infinite whose elements onetoone correspondence integers thus boolos jeffrey saying algorithm implies instructions process creates output integers arbitrary input integer integers theory arbitrarily large thus algorithm algebraic equation arbitrary input variables produce output various authors attempts define notion indicate word implies much something order addition example

precise instructions language understood computer21 fast efficient good22 process specifies moves computer machine human equipped necessary internally contained information capabilities23 find decode process arbitrary input integerssymbols symbols effectively24 produce reasonable time25 outputinteger specified place specified format

concept algorithm also used define notion decidability notion central explaining formal systems come starting small axioms rules logic time algorithm requires complete cannot measured apparently related customary physical dimension uncertainties characterize ongoing work stems unavailability definition algorithm suits concrete sense abstract usage term
formalizationedit
algorithms essential computers process data many computer programs contain algorithms detail specific instructions computer perform specific order carry specified task calculating employees paychecks printing students report cards thus algorithm considered sequence operations simulated turingcomplete system authors assert thesis include minsky 1967 savage 1987 gurevich 2000

minsky also maintain turing procedure could naturally called effective fact realized simple machine although seem extreme arguments favor hard refute26


gurevich turings informal argument favor thesis justifies stronger thesis every algorithm simulated turing machine according savage 1987 algorithm computational process defined turing machine27

typically algorithm associated processing information data read input source written output device stored processing stored data regarded part internal state entity performing algorithm practice state stored data structures
computational process algorithm must rigorously defined specified applies possible circumstances could arise conditional steps must systematically dealt casebycase criteria case must clear computable
algorithm precise list precise steps order computation always crucial functioning algorithm instructions usually assumed listed explicitly described starting going bottom idea described formally flow control
discussion formalization algorithm assumed premises imperative programming common conception attempts describe task discrete mechanical means unique conception formalized algorithms assignment operation setting value variable derives intuition memory scratchpad example assignment
alternate conceptions constitutes algorithm functional programming logic programming
expressing algorithmsedit
algorithms expressed many kinds notation including natural languages pseudocode flowcharts drakoncharts programming languages control tables processed interpreters natural language expressions algorithms tend verbose ambiguous rarely used complex technical algorithms pseudocode flowcharts drakoncharts control tables structured ways express algorithms avoid many ambiguities common natural language statements programming languages primarily intended expressing algorithms form executed computer often used define document algorithms
wide variety representations possible express given turing machine program sequence machine tables finitestate machine state transition table control table flowcharts drakoncharts state diagram form rudimentary machine code assembly code called sets quadruples turing machine
representations algorithms classed three accepted levels turing machine description28

highlevel description
prose describe algorithm ignoring implementation details level need mention machine manages tape head
implementation description
prose used define turing machine uses head stores data tape level give details states transition function
formal description
detailed lowest level gives turing machines state table

example simple algorithm described three levels algorithmexamples
implementationedit




logical nand algorithm implemented electronically 7400 chip


algorithms intended implemented computer programs however algorithms also implemented means biological neural network example human brain implementing arithmetic insect looking food electrical circuit mechanical device
computer algorithmsedit




flowchart examples canonical böhmjacopini structures sequence rectangles descending page whiledo ifthenelse three structures made primitive conditional goto testtrue goto step diamond unconditional goto rectangle various assignment operators rectangle halt rectangle nesting structures inside assignmentblocks result complex diagrams tausworthe 1977100114


computer systems algorithm basically instance logic written software software developers effective intended target computers produce output given perhaps null input optimal algorithm even running hardware would produce faster results nonoptimal higher time complexity algorithm purpose running efficient hardware algorithms like computer hardware considered technology
elegant compact programs good fast programs notion simplicity elegance appears informally knuth precisely chaitin

knuth want good algorithms loosely defined aesthetic sense criterion length time taken perform algorithm criteria adaptability algorithm computers simplicity elegance etc29


chaitin program elegant mean smallest possible program producing output does30

chaitin prefaces definition show cant prove program elegant—such proof would solve halting problem ibid
algorithm versus function computable algorithm given function multiple algorithms exist true even without expanding available instruction available programmer rogers observes important distinguish notion algorithm procedure notion function computable algorithm mapping yielded procedure function several different algorithms31
unfortunately tradeoff goodness speed elegance compactness—an elegant program take steps complete computation less elegant example uses euclids algorithm appears
computers computors models computation computer human computor32 restricted type machine discrete deterministic mechanical device33 blindly follows instructions34 melzaks lambeks primitive models35 reduced notion four elements discrete distinguishable locations discrete indistinguishable counters36 agent list instructions effective relative capability agent37
minsky describes congenial variation lambeks abacus model simple bases computability38 minskys machine proceeds sequentially five depending counts instructions unless either conditional if–then goto unconditional goto changes program flow sequence besides halt minskys machine includes three assignment replacement substitution39 operations zero contents location replaced successor decrement rarely must programmer write code limited instruction minsky shows melzak lambek machine turing complete four general types instructions conditional goto unconditional goto assignmentreplacementsubstitution halt41
simulation algorithm computer computor language knuth advises reader best learn algorithm immediately take paper work example42 simulation execution real thing programmer must translate algorithm language simulatorcomputercomputor effectively execute stone gives example computing roots quadratic equation computor must know take square root dont algorithm effective must provide rules extracting square root43
means programmer must know language effective relative target computing agent computercomputor
model used simulation emde boas observes even base complexity theory abstract instead concrete machines arbitrariness choice model remains point notion simulation enters44 speed measured instruction matters example subprogram euclids algorithm compute remainder would execute much faster programmer modulus instruction available rather subtraction worse minskys decrement
structured programming canonical structures church–turing thesis algorithm computed model known turing complete minskys demonstrations turing completeness requires four instruction types—conditional goto unconditional goto assignment halt kemeny kurtz observe undisciplined unconditional gotos conditional ifthen gotos result spaghetti code programmer write structured programs using instructions hand also possible hard write badly structured programs structured language45 tausworthe augments three böhmjacopini canonical structures46 sequence ifthenelse whiledo dowhile case47 additional benefit structured program lends proofs correctness using mathematical induction48
canonical flowchart symbols49 graphical aide called flowchart offers describe document algorithm computer program like program flow minsky machine flowchart always starts page proceeds primary symbols four directed arrow showing program flow rectangle sequence goto diamond ifthenelse ortie böhm–jacopini canonical structures made primitive shapes substructures nest rectangles single exit occurs superstructure symbols build canonical structures shown diagram
examplesedit
information list algorithms
algorithm exampleedit




animation quicksort algorithm sorting array randomized values bars mark pivot element start animation element farthest right hand side chosen pivot


simplest algorithms find largest number list numbers random order finding solution requires looking every number list follows simple algorithm stated highlevel description english prose
highlevel description

numbers highest number
assume first number largest number
remaining number number larger current largest number consider number largest number
numbers left iterate consider current largest number largest number

quasiformal description written prose much closer highlevel language computer program following formal coding algorithm pseudocode pidgin code


algorithm largestnumber
input list numbers
output largest number list


lsize return null
largest
item
item largest
largest item
return largest


shorthand changes instance largest item means value largest changes value item
return terminates algorithm outputs value follows


euclids algorithmedit
information euclids algorithm




examplediagram euclids algorithm heath 1908 detail added euclid beyond third measuring gives numerical examples nicomachus gives example subtract less greater left subtract possible left subtract left subtract possible left cannot subtracted heath comments last phrase curious meaning obvious enough also meaning phrase ending numberheath 1908300


euclids algorithm compute greatest common divisor numbers appears proposition book elementary number theory elements50 euclid poses problem thus given numbers prime another find greatest common measure defines number multitude composed units counting number positive integer including zero measure place shorter measuring length successively times along longer length remaining portion less shorter length modern words remainder quotient remainder modulus integerfractional part left division52
euclids method succeed starting lengths must satisfy requirements lengths must zero subtraction must “proper” test must guarantee smaller numbers subtracted larger alternately equal subtraction yields zero
euclids original proof adds third requirement lengths must prime another euclid stipulated could construct reductio absurdum proof numbers common measure fact greatest53 nicomachus algorithm euclids numbers prime another yields number common measure precise following really nicomachus algorithm




graphical expression euclids algorithm find greatest common divisor 1599


1599 650×2
299×2
52×5
39×1
13×3





computer language euclids algorithmedit
instruction types required execute euclids algorithm—some logical tests conditional goto unconditional goto assignment replacement subtraction

location symbolized upper case letters
varying quantity number location written lower case letters usually associated locations name example location start might contain number 3009

inelegant program euclids algorithmedit




inelegant translation knuths version algorithm subtractionbased remainderloop replacing division modulus instruction derived knuth 19732–4 depending numbers inelegant compute fewer steps elegant


following algorithm framed knuths fourstep version euclids nicomachus rather using division find remainder uses successive subtractions shorter length remaining length less highlevel description shown boldface adapted knuth 19732–4
input

locations numbers represent lengths
input
initialize make remaining length equal startinginitialinput length


ensure

ensure smaller numbers larger

contents larger number skip exchangesteps
goto step
else
swap contents
first step redundant useful later discussion



find remainder remaining length less shorter length repeatedly subtract measuring number remaining length


done measuring
goto
else
measure

remainderloop
goto

remainder zero either last measure exact remainder zero program halt algorithm must continue last measure left remainder less measuring number


done
goto step
else
continue step

interchange euclids algorithm remainder measure previously smaller number serves temporary location




repeat measuring process
goto

output

done contains greatest common divisor
print

done

halt stop

elegant program euclids algorithmedit
following version euclids algorithm requires core instructions thirteen required inelegant worse inelegant requires types instructions flowchart elegant found article unstructured basic language steps numbered instruction assignment instruction symbolized


euclids algorithm greatest common divisor
print type integers greater
input
goto
goto

goto

goto
print


following version used object oriented languages


euclids algorithm greatest common divisor
integer euclidalgorithm
amathabsa
bmathabsb


else

return


elegant works place outer euclid loop elegant shifts back forth coloops loop computes loop computes works last minuend less equal subtrahend difference minuend subtrahend minuend become measuring length subtrahend become length measured words sense subtraction reverses
testing euclid algorithmsedit
algorithm author wants test cases usually suffice confirm core functionality source54 uses 3009 knuth suggested 40902 24140 another interesting case relatively prime numbers 14157 5950
exceptional cases must identified tested inelegant perform properly ditto elegant happens number zero numbers zero inelegant computes forever cases elegant computes forever happens negative numbers entered fractional numbers input numbers domain function computed algorithmprogram include positive integers including zero failures zero indicate algorithm program instantiates partial function rather total function notable failure exceptions ariane flight rocket failure june 1996
proof program correctness mathematical induction knuth demonstrates application mathematical induction extended version euclids algorithm proposes general method applicable proving validity algorithm55 tausworthe proposes measure complexity program length correctness proof56
measuring improving euclid algorithmsedit
elegance compactness versus goodness speed core instructions elegant clear winner compared inelegant thirteen instructions however inelegant faster arrives halt fewer steps algorithm analysis57 indicates case elegant conditional tests every subtraction loop whereas inelegant algorithm usually requires many loopthroughs average much time wasted test needed remainder computed
algorithms improved programmer judges program effective—that computes function intended author—then question becomes improved
compactness inelegant improved elimination five steps chaitin proved compacting algorithm cannot automated generalized algorithm58 rather done heuristically exhaustive search examples found busy beaver trial error cleverness insight application inductive reasoning observe steps repeated steps comparison elegant provides hint steps together steps eliminated reduces number core instructions thirteen eight makes elegant elegant nine steps
speed elegant improved moving test outside subtraction loops change calls addition three instructions goto elegant computes examplenumbers faster whether always case given would require detailed analysis
algorithmic analysisedit
main article analysis algorithms
frequently important know much particular resource time storage theoretically required given algorithm methods developed analysis algorithms obtain quantitative answers estimates example sorting algorithm time requirement using notation length list times algorithm needs remember values largest number found current position input list therefore said space requirement space required store input numbers counted counted
different algorithms complete task different instructions less time space effort others example binary search algorithm cost olog outperforms sequential search cost used table lookups sorted lists arrays
formal versus empiricaledit
main articles empirical algorithmics profiling computer programming program optimization
analysis study algorithms discipline computer science often practiced abstractly without specific programming language implementation sense algorithm analysis resembles mathematical disciplines focuses underlying properties algorithm specifics particular implementation usually pseudocode used analysis simplest general representation however ultimately algorithms usually implemented particular hardware software platforms algorithmic efficiency eventually test using real code solution problem efficiency particular algorithm significant consequences unless extremely large algorithms designed fast interactive commercial long life scientific usage critical scaling small large frequently exposes inefficient algorithms otherwise benign
empirical testing useful uncover unexpected interactions affect performance benchmarks used compare beforeafter potential improvements algorithm program optimization
execution efficiencyedit
main article algorithmic efficiency
illustrate potential improvements possible even well established algorithms recent significant innovation relating algorithms used heavily field image processing decrease processing time 1000 times applications like medical imaging59 general speed improvements depend special properties problem common practical applications60 speedups magnitude enable computing devices make extensive image processing like digital cameras medical equipment consume less power
classificationedit
various ways classify algorithms merits
implementationedit
classify algorithms implementation means

recursion
recursive algorithm invokes makes reference repeatedly certain condition also known termination condition matches method common functional programming iterative algorithms repetitive constructs like loops sometimes additional data structures like stacks solve given problems problems naturally suited implementation example towers hanoi well understood using recursive implementation every recursive version equivalent possibly less complex iterative version vice versa
logical
algorithm viewed controlled logical deduction notion expressed algorithm logic control61 logic component expresses axioms used computation control component determines deduction applied axioms basis logic programming paradigm pure logic programming languages control component fixed algorithms specified supplying logic component appeal approach elegant semantics change axioms welldefined change algorithm
serial parallel distributed
algorithms usually discussed assumption computers execute instruction algorithm time computers sometimes called serial computers algorithm designed environment called serial algorithm opposed parallel algorithms distributed algorithms parallel algorithms take advantage computer architectures several processors work problem time whereas distributed algorithms utilize multiple machines connected network parallel distributed algorithms divide problem symmetrical asymmetrical subproblems collect results back together resource consumption algorithms processor cycles processor also communication overhead processors sorting algorithms parallelized efficiently communication overhead expensive iterative algorithms generally parallelizable problems parallel algorithms called inherently serial problems
deterministic nondeterministic
deterministic algorithms solve problem exact decision every step algorithm whereas nondeterministic algorithms solve problems guessing although typical guesses made accurate heuristics
exact approximate
many algorithms reach exact solution approximation algorithms seek approximation closer true solution approximation reached either using deterministic random strategy algorithms practical value many hard problems examples approximate algorithm knapsack problem knapsack problem problem given items goal problem pack knapsack maximum total value item weight value total weight carry fixed number must consider weights items well value62
quantum algorithm
realistic model quantum computation term usually used algorithms seem inherently quantum essential feature quantum computation quantum superposition quantum entanglement

design paradigmedit
another classifying algorithms design methodology paradigm certain number paradigms different furthermore categories include many different types algorithms common paradigms

bruteforce exhaustive search
naive method trying every possible solution best63
divide conquer
divide conquer algorithm repeatedly reduces instance problem smaller instances problem usually recursively instances small enough solve easily example divide conquer merge sorting sorting done segment data dividing data segments sorting entire data obtained conquer phase merging segments simpler variant divide conquer called decrease conquer algorithm solves identical subproblem uses solution subproblem solve bigger problem divide conquer divides problem multiple subproblems conquer stage complex decrease conquer algorithms example decrease conquer algorithm binary search algorithm
search enumeration
many problems playing chess modeled problems graphs graph exploration algorithm specifies rules moving around graph useful problems category also includes search algorithms branch bound enumeration backtracking
randomized algorithm
algorithms make choices randomly pseudorandomly useful finding approximate solutions problems finding exact solutions impractical heuristic method problems known fastest approximations must involve randomness64 whether randomized algorithms polynomial time complexity fastest algorithms problems open question known versus problem large classes algorithms


monte carlo algorithms return correct answer highprobability subclass polynomial time
vegas algorithms always return correct answer running time probabilistically bound


reduction complexity
technique involves solving difficult problem transforming better known problem hopefully asymptotically optimal algorithms goal find reducing algorithm whose complexity dominated resulting reduced algorithms example selection algorithm finding median unsorted list involves first sorting list expensive portion pulling middle element sorted list cheap portion technique also known transform conquer

optimization problemsedit
optimization problems specific classification algorithms algorithm problems fall general categories described well following

linear programming
searching optimal solutions linear function bound linear equality inequality constraints constraints problem used directly producing optimal solutions algorithms solve problem category popular simplex algorithm65 problems solved linear programming include maximum flow problem directed graphs problem additionally requires unknowns must integer classified integer programming linear programming algorithm solve problem proved restrictions integer values superficial solutions satisfy restrictions anyway general case specialized algorithm algorithm finds approximate solutions used depending difficulty problem
dynamic programming
problem shows optimal substructures meaning optimal solution problem constructed optimal solutions subproblems overlapping subproblems meaning subproblems used solve many different problem instances quicker approach called dynamic programming avoids recomputing solutions already computed example floyd–warshall algorithm shortest path goal vertex weighted graph found using shortest path goal adjacent vertices dynamic programming memoization together main difference dynamic programming divide conquer subproblems less independent divide conquer whereas subproblems overlap dynamic programming difference dynamic programming straightforward recursion caching memoization recursive calls subproblems independent repetition memoization help hence dynamic programming solution complex problems using memoization maintaining table subproblems already solved dynamic programming reduces exponential nature many problems polynomial complexity
greedy method
greedy algorithm similar dynamic programming algorithm works examining substructures case problem given solution algorithms start solution given constructed improve making small modifications problems find optimal solution others stop local optima solutions cannot improved algorithm optimum popular greedy algorithms finding minimal spanning tree finding optimal solution possible method huffman tree kruskal prim sollin greedy algorithms solve optimization problem
heuristic method
optimization problems heuristic algorithms used find solution close optimal solution cases finding optimal solution impractical algorithms work getting closer closer optimal solution progress principle infinite amount time find optimal solution merit find solution close optimal solution relatively short time algorithms include local search tabu search simulated annealing genetic algorithms like simulated annealing nondeterministic algorithms others like tabu search deterministic bound error nonoptimal solution known algorithm categorized approximation algorithm

field studyedit
also list algorithms
every field science problems needs efficient algorithms related problems field often studied together example classes search algorithms sorting algorithms merge algorithms numerical algorithms graph algorithms string algorithms computational geometric algorithms combinatorial algorithms medical algorithms machine learning cryptography data compression algorithms parsing techniques
fields tend overlap algorithm advances field improve sometimes completely unrelated fields example dynamic programming invented optimization resource consumption industry used solving broad range problems many fields
complexityedit
also complexity class parameterized complexity
algorithms classified amount time need complete compared input size

constant time time needed algorithm regardless input size access array element
linear time time proportional input size traverse list
logarithmic time time logarithmic function input size binary search algorithm
polynomial time time power input size bubble sort algorithm quadratic time complexity
exponential time time exponential function input size bruteforce search

problems multiple algorithms differing complexity problems might algorithms known efficient algorithms also mappings problems problems owing found suitable classify problems instead algorithms equivalence classes based complexity best possible algorithms
continuous algorithmsedit
adjective continuous applied word algorithm mean

algorithm operating data represents continuous quantities even though data represented discrete approximations—such algorithms studied numerical analysis
algorithm form differential equation operates continuously data running analog computer66

legal issuesedit
also software patent
algorithms usually patentable united states claim consisting solely simple manipulations abstract concepts numbers signals constitute processes uspto 2006 hence algorithms patentable gottschalk benson however practical applications algorithms sometimes patentable example diamond diehr application simple feedback algorithm curing synthetic rubber deemed patentable patenting software highly controversial highly criticized patents involving algorithms especially data compression algorithms unisys patent
additionally cryptographic algorithms export restrictions export cryptography
researcher andrew tutt argues algorithms overseen specialist regulatory agency similar academic work emphasizes rise increasingly complex algorithms calls need think effects algorithms today nature complexity algorithms prove difficult hold algorithms accountable criminal tutt recognizes algorithms beneficial help meet technological demand others used sold fail meet safety requirements thus tutt algorithms require closer forms federal uniformity expert judgment political independence premarket review prevent introduction unacceptably dangerous algorithms market67 issue algorithmic accountability68 responsibility algorithm designers provide evidence potential realised harms particular relevance field dynamic nonlinearly programmed systems artificial neural networks deep learning genetic algorithms explainable
history development notion algorithmedit
ancient near eastedit
algorithms used ancient greece examples sieve eratosthenes described introduction arithmetic nicomachus6970ch euclidean algorithm first described euclids elements bc70ch babylonian clay tablets describe employ algorithmic procedures compute time place significant astronomical events71
discrete distinguishable symbolsedit
tallymarks keep track flocks sacks grain money ancients used tallying accumulating stones marks scratched sticks making discrete symbols clay babylonian egyptian marks symbols eventually roman numerals abacus evolved dilson 16–41 tally marks appear prominently unary numeral system arithmetic used turing machine post–turing machine computations
manipulation symbols place holders numbers algebraedit
work ancient greek geometers euclidean algorithm indian mathematician brahmagupta islamic mathematics alkhwarizmi whose name terms algorism algorithm derived western european mathematicians culminated leibnizs notion calculus ratiocinator 1680

good century half ahead time leibniz proposed algebra logic algebra would specify rules manipulating logical concepts manner ordinary algebra specifies rules manipulating numbers72

mechanical contrivances discrete statesedit
clock bolter credits invention weightdriven clock invention europe middle ages particular verge escapement73 provides tick tock mechanical clock accurate automatic machine74 immediately mechanical automata beginning 13th century finally computational machines—the difference engine analytical engines charles babbage countess lovelace mid19th century75 lovelace credited first creation algorithm intended processing computer babbages analytical engine first device considered real turingcomplete computer instead calculator sometimes called historys first programmer result though full implementation babbages second device would realized decades lifetime
logical machines 1870—stanley jevons logical abacus logical machine technical problem reduce boolean equations presented form similar known karnaugh maps jevons 1880 describes first simple abacus slips wood furnished pins contrived part class logical combinations picked mechanically recently however reduced system completely mechanical form thus embodied whole indirect process inference called logical machine machine came equipped certain moveable wooden rods foot keys like piano machine could analyze syllogism simple logical argument76
machine displayed 1870 fellows royal society77 another logician john venn however 1881 symbolic logic turned jaundiced effort high estimate interest importance sometimes called logical machines seem contrivances present known likely discovered really deserve name logical machines algorithm characterizations outdone presented plan somewhat analogous apprehend prof jevons abacus corresponding prof jevonss logical machine following contrivance described prefer call merely logicaldiagram machine suppose could completely rationally expected logical machine78
jacquard loom hollerith punch cards telegraphy telephony—the electromechanical relay bell newell 1971 indicate jacquard loom 1801 precursor hollerith cards punch cards 1887 telephone switching technologies roots tree leading development first computers79 mid19th century telegraph precursor telephone throughout world discrete distinguishable encoding letters dots dashes common sound late 19th century ticker tape 1870s hollerith cards 1890 census came teleprinter 1910 punchedpaper baudot code tape
telephoneswitching networks electromechanical relays invented 1835 behind work george stibitz 1937 inventor digital adding device worked bell laboratories observed burdensome mechanical calculators gears went home evening 1937 intending test idea tinkering stibitz constructed binary adding device80
davis 2000 observes particular importance electromechanical relay binary states open closed

development beginning 1930s electromechanical calculators using electrical relays machines built scope babbage envisioned81

mathematics 19th century mid20th centuryedit
symbols rules rapid succession mathematics george boole 1847 1854 gottlob frege 1879 giuseppe peano 1888–1889 reduced arithmetic sequence symbols manipulated rules peanos principles arithmetic presented method 1888 first attempt axiomatization mathematics symbolic language82
heijenoort gives frege 1879 kudos freges perhaps important single work ever written logic formula language lingua characterica language written special symbols pure thought free rhetorical embellishments constructed specific symbols manipulated according definite rules83 work frege simplified amplified alfred north whitehead bertrand russell principia mathematica 1910–1913
paradoxes time number disturbing paradoxes appeared literature particular buraliforti paradox 1897 russell paradox 1902–03 richard paradox84 resultant considerations kurt gödels paper 1931—he specifically cites paradox liar—that completely reduces rules recursion numbers
effective calculability effort solve entscheidungsproblem defined precisely hilbert 1928 mathematicians first define meant effective method effective calculation effective calculability calculation would succeed rapid succession following appeared alonzo church stephen kleene rossers λcalculus85 finely honed definition general recursion work gödel acting suggestions jacques herbrand gödels princeton lectures 1934 subsequent simplifications kleene86 churchs proof87 entscheidungsproblem unsolvable emil posts definition effective calculability worker mindlessly following list instructions move left right sequence rooms either mark erase paper observe paper make yesno decision next instruction88 alan turings proof entscheidungsproblem unsolvable automatic machine89—in effect almost identical posts formulation barkley rossers definition effective method terms machine90 kleenes proposal precursor church thesis called thesis years later kleenes renaming thesis churchs thesis92 proposing turings thesis93
emil post 1936 alan turing 1936–37 1939edit
remarkable coincidenceaccording knowing describing process menascomputers working computations—and yield virtually identical definitions
emil post 1936 described actions computer human follows

concepts involved symbol space work leading problem answer carried fixed unalterable directions

symbol space would

infinite sequence spaces boxes problem solver worker move work symbol space capable operating time admit possible conditions empty unmarked single mark vertical stroke


singled called starting point specific problem given symbolic form finite number boxes input marked stroke likewise answer output given symbolic form configuration marked boxes


directions applicable general problem sets deterministic process applied specific problem process terminates comes direction type stop94 post–turing machine





alan turings statue bletchley park


alan turings work95 preceded stibitz 1937 unknown whether stibitz knew work turing turings biographer believed turings typewriterlike model derived youthful interest alan dreamt inventing typewriters turing typewriter could well begun asking meant calling typewriter mechanical96 given prevalence morse code telegraphy ticker tape machines teletypewriters wewho might conjecture influences
turing—his model computation called turing machine—begins post analysis human computer whittles simple basic motions states mind continues step creates machine model computation numbers97

computing normally done writing certain symbols paper suppose paper divided squares like childs arithmetic booki assume computation carried onedimensional paper tape divided squares shall also suppose number symbols printed finite


behaviour computer moment determined symbols observing state mind moment suppose bound number symbols squares computer observe moment wishes observe must successive observations also suppose number states mind need taken account finite


imagine operations performed computer split simple operations elementary easy imagine divided98

turings reduction yields following

simple operations must therefore include

changes symbol observed squares
changes squares observed another square within squares previously observed squares



change necessarily invoke change state mind general single operation must therefore taken following



possible change symbol together possible change state mind
possible change observed squares together possible change state mind




construct machine work computer98

years later turing expanded analysis thesis definition forceful expression

function said effectively calculable values found purely mechanical process though fairly easy intuitive grasp idea nevertheless desirable definite mathematical expressible definition discusses history definition pretty much presented respect gödel herbrand kleene church turing post take statement literally understanding purely mechanical process could carried machine possible give mathematical description certain normal form structures machines development ideas leads authors definition computable function identification computability effective calculability

shall expression computable function mean function calculable machine effectively calculable refer intuitive idea without particular identification definitions99



rosser 1939 kleene 1943edit
barkley rosser defined effective mathematical method following manner italicization added

effective method used rather special sense method step precisely determined certain produce answer finite number steps special meaning three different precise definitions given date footnote discussion immediately simplest state post turing says essentially effective method solving certain sets problems exists build machine solve problem human intervention beyond inserting question later reading answer three definitions equivalent doesnt matter used moreover fact three equivalent strong argument correctness rosser 1939225–6

rossers footnote references work church kleene definition λdefinability particular churchs unsolvable problem elementary number theory 1936 herbrand gödel recursion particular gödels famous paper formally undecidable propositions principia mathematica related systems 1931 post 1936 turing 1936–37 mechanismmodels computation
stephen kleene defined nowfamous thesis known church–turing thesis following context boldface original

algorithmic theories setting complete algorithmic theory describe procedure performable values independent variables procedure necessarily terminates manner outcome read definite answer question predicate value true kleene 1943273

history 1950edit
number efforts directed toward refinement definition algorithm activity ongoing issues surrounding particular foundations mathematics especially church–turing thesis philosophy mind especially arguments artificial intelligence algorithm characterizations
alsoedit


heuristic
abstract machine
algorithm engineering
algorithm characterizations
algorithmic composition
algorithmic synthesis
algorithmic trading
garbage garbage
introduction algorithms textbook
list algorithms
list algorithm general topics
list important publications theoretical computer science algorithms
numerical mathematics consortium
theory computation

computability theory
computational complexity theory




notesedit


classical mathematical algorithm example described finite number english words rogers 19872
well defined respect agent executes algorithm computing agent usually human react instructions carry computations rogers 19872
algorithm procedure computing function respect chosen notation integers limitation numerical functions results loss generality rogers 19871
algorithm zero inputs quantities given initially algorithm begins knuth 19735
procedure characteristics algorithm except possibly lacks finiteness called computational method knuth 19735
algorithm outputs quantities specified relation inputs knuth 19735
whether process random interior processes including input algorithm debatable rogers opines computation carried discrete stepwise fashion without continuous methods analogue devices carried forward deterministically without resort random methods devices dice rogers 19872
kleene 1943 davis 1965274
rosser 1939 davis 1965225
moschovakis yiannis 2001 algorithm engquist schmid mathematics unlimited 2001 beyond springer 919–936 part isbn 9783540669135
alkhwarizmi biography wwwhistorymcsstandrewsacuk
etymology algorithm chambers dictionary retrieved december 2016
hogendijk 1998 alkhwarzimi pythagoras archived original april 2009
oaks jeffrey alkhwarizmi applied algebraist university indianapolis retrieved 2008
brezina corona 2006 alkhwarizmi inventor algebra rosen publishing group isbn 9781404205130
foremost mathematical texts history according carl boyer
oxford english dictionary third edition 2012
stone 19734
stone simply requires must terminate finite number steps stone 19737–8
boolos jeffrey 1974199919
stone 19725
knuth 19737 states practice want algorithms want good algorithms criterion goodness length time taken perform algorithm criteria adaptability algorithm computers simplicity elegance
stone 19736
stone 19737–8 states must procedure robot computer follow order determine precisely obey instruction stone adds finiteness process definiteness ambiguity instructions definition
knuth
minsky 1967
gurevich 20001
sipser 2006157
knuth 19737
chaitin 200532
rogers 19871–2
essay calculations machine conceptual analysis seig 2002390 credits distinction robin gandy wilfred seig 2002 reflections foundations mathematics essays honor solomon feferman association symbolic logic peters natick
gandy 1980126 robin gandy churchs thesis principles mechanisms appearing 123–148 barwise 1980 kleene symposium northholland publishing company
robot computer robot performs task described sequence instructions stone 19723
lambeks abacus countably infinite number locations holes wires together unlimited supply counters pebbles beads locations distinguishable counters holes unlimited capacity standing agent understands able carry list instructions lambek 1961295 lambek references melzak defines qmachine indefinitely large number locations indefinitely large supply counters distributed among locations program operator whose sole purpose carry program melzak 1961283 stipulation holes capable holding number stones melzak lambek appear canadian mathematical bulletin september 1961
confusion results word counters dropped location said contain single number
instruction effective procedure robot follow order determine precisely obey instruction stone 19726
minsky 1967 chapter computer models chapter simple bases computability 255–281 particular
knuth 19733
always preceded if–then avoid improper subtraction
however different assignment instructions decrement increment zeroclearempty minsky machine also required turingcompleteness exact specification somewhat designer unconditional goto convenience constructed initializing dedicated location zero instruction thereafter instruction goto unconditional
knuth 19734
stone 19725 methods extracting roots trivial methods computing square roots
leeuwen 1990 handbook theoretical computer science algorithms complexity volume elsevier isbn 9780444880710
john kemeny thomas kurtz 1985 back basic history corruption future language addisonwesley publishing company reading isbn 0201134330
tausworthe 1977101
tausworthe 1977142
knuth 1973 section expanded tausworthe 1977 pages 100ff chapter
tausworthe 1977
heath 1908300 hawkings dover 2005 edition derives heath
measuring leave less neat abbreviation saying measure along successive lengths equal point reached length remaining less words largest exact multiple contained heath 1908297
modern treatments using division algorithm hardy wright 1979180 knuth 19732 volume plus discussion euclids algorithm knuth 1969293–297 volume
euclid covers question proposition
euclids elements book proposition aleph0clarkuedu retrieved 2012
knuth 197313–18 credits formulation algorithmproving terms assertions induction floyd peter naur hoare goldstine neumann tausworth 1977 borrows knuths euclid example extends knuths method section formal proofs pages 288–298
tausworthe 1997294
knuth 19737 moredetailed analyses 1969294–313
breakdown occurs algorithm tries compact success would solve halting problem
gillian conahan january 2013 better math makes faster data networks discovermagazinecom
haitham hassanieh piotr indyk dina katabi eric price acmsiam symposium discrete algorithms soda archived july 2013 wayback machine kyoto january 2012 also sfft page
kowalski 1979
knapsack problems hans kellerer springer
carroll daughtrey july 2007 fundamental concepts software quality engineer american society quality isbn 9780873897204
instance volume convex polytope described using membership oracle approximated high accuracy randomized polynomial time algorithm deterministic dyer martin frieze alan kannan ravi january 1991 random polynomialtime algorithm approximating volume convex bodies york 1–17 citeseerx 10111454600 doi101145102782102783
george dantzig mukund thapa 2003 linear programming theory extensions springerverlag
tsypkin 1971 adaptation learning automatic systems academic press isbn 9780080955827
tutt andrew march 2016 algorithms administrative review ssrn 2747994
algorithmic accountability applying concept different country contexts httpwebfoundationorgdocs201707algorithmsreportwfpdf foundation 2017
eratosthenes
cooke roger 2005 history mathematics brief course john wiley sons isbn 9781118460290
aaboe asger 2001 episodes early history astronomy york springer 40–62 isbn 0387951369
davis 200018
bolter 198424
bolter 198426
bolter 198433–34 204–206
quotes stanley jevons 1880 elementary lessons logic deductive inductive macmillan london york republished googlebook jevons 1880199–201 louis couturat 1914 algebra logic open court publishing company chicago london republished googlebook couturat 191475–76 gives details interestingly compares typewriter well piano jevons states account found 1870 proceedings royal society
jevons 1880199–200
quotes john venn 1881 symbolic logic macmillan london republished googlebook venn 1881120–125 interested reader find deeper explanation pages
bell newell diagram 197139 davis 2000
melina hill valley news correspondent tinkerer gets place history valley news west lebanon thursday march 1983 page
davis 200014
heijenoort 196781ff
heijenoorts commentary freges begriffsschrift formula language modeled upon arithmetic pure thought heijenoort 19671
dixon 1906 kleene 195236–40
footnote alonzo church 1936a davis 196590 1936b davis 1965110
kleene 1935–6 davis 1965237ff kleene 1943 davis 1965255ff
church 1936 davis 196588ff
formulation post 1936 davis 1965289–290
turing 1936–7 davis 1965116ff
rosser 1939 davis 1965226
kleene 1943 davis 1965273–274
kleene 1952300
kleene 1952376
turing 1936–7 davis 1965289–290
turing 1936 davis 1965 turing 1939 davis 1965160
hodges
turing 1936–7116
turing 1936–7 davis 1965136
turing 1939 davis 1965160


referencesedit

bibliographyedit

1959 subrecursive hierarchy primitive recursive degrees transactions american mathematical society 85–105 doi1023071993169 jstor 1993169
bell gordon newell allen 1971 computer structures readings examples mcgraw–hill book company york isbn 0070043574
blass andreas gurevich yuri 2003 algorithms quest absolute definitions bulletin european association theoretical computer science includes excellent bibliography references
boolos george jeffrey richard 1999 1974 computability logic cambridge university press london isbn 052120402x chapter turing machines discuss certain enumerable sets effectively mechanically enumerable
burgin mark 2004 superrecursive algorithms springer isbn 9780387955698
campagnolo moore costa 2000 analog characterization subrecursive functions proc conference real numbers computers odense university 91–109
church alonzo 1936a unsolvable problem elementary number theory american journal mathematics 345–363 doi1023072371045 jstor 2371045 reprinted undecidable 89ff first expression churchs thesis particular page undecidable defines notion effective calculability terms algorithm uses word terminates
church alonzo 1936b note entscheidungsproblem journal symbolic logic 40–41 doi1023072269326 jstor 2269326 church alonzo 1936 correction note entscheidungsproblem journal symbolic logic 101–102 doi1023072269030 jstor 2269030 reprinted undecidable 110ff church shows entscheidungsproblem unsolvable pages text pages footnotes
daffa abdullah 1977 muslim contribution mathematics london croom helm isbn 0856644641
davis martin 1965 undecidable basic papers undecidable propositions unsolvable problems computable functions york raven press isbn 0486432289 davis gives commentary article papers gödel alonzo church turing rosser kleene emil post included cited article listed authors name
davis martin 2000 engines logic mathematicians origin computer york nortion isbn 0393322297 davis offers concise biographies leibniz boole frege cantor hilbert gödel turing neumann showstealing villain brief bios josephmarie jacquard babbage lovelace claude shannon howard aiken
article incorporates public domain material nist document black paul algorithm dictionary algorithms data structures
dean 2012 evolution moral diversity baltic international yearbook cognition logic communication
dennett daniel 1995 darwins dangerous idea york touchstonesimon schuster isbn 0684802902
yuri gurevich sequential abstract state machines capture sequential algorithms transactions computational logic july 2000 pages 77–111 includes bibliography sources
kleene stephen 1936 general recursive functions natural numbers mathematische annalen 727–742 doi101007bf01565439 presented american mathematical society september 1935 reprinted undecidable 237ff kleenes definition general recursion known murecursion used church 1935 paper unsolvable problem elementary number theory proved decision problem undecidable negative result
kleene stephen 1943 recursive predicates quantifiers american mathematical society transactions 41–73 doi1023071990131 jstor 1990131 reprinted undecidable 255ff kleene refined definition general recursion proceeded chapter algorithmic theories posit thesis would later repeat thesis kleene 1952300 name churchs thesiskleene 1952317 church thesis
kleene stephen 1991 1952 introduction metamathematics tenth northholland publishing company isbn 0720421039 excellent—accessible readable—reference source mathematical foundations
knuth donald 1997 fundamental algorithms third edition reading massachusetts addison–wesley isbn 0201896834
knuth donald 1969 volume 2seminumerical algorithms computer programming first edition reading massachusetts addison–wesley
kosovsky elements mathematical logic application theory subrecursive algorithms publ leningrad 1981
kowalski robert 1979 algorithmlogiccontrol communications 424–436 doi101145359131359136
markov 1954 theory algorithms translated jacques schorrkon staff imprint moscow academy sciences ussr 1954 jerusalem israel program scientific translations 1961 available office technical services dept commerce washington description added russian translation works mathematical institute academy sciences ussr original title teoriya algerifmov qa248m2943 dartmouth college library dept commerce office technical services number 6051085
minsky marvin 1967 computation finite infinite machines first prenticehall englewood cliffs isbn 0131654497 minsky expands idea algorithm—an effective procedure chapter computability effective procedures algorithms infinite machines
post emil 1936 finite combinatory processes formulation journal symbolic logic 103–105 doi1023072269031 jstor 2269031 reprinted undecidable 289ff post defines simple algorithmiclike process writing marks erasing marks going eventually halting follows list simple instructions cited kleene source thesis socalled church–turing thesis
rogers hartley 1987 theory recursive functions effective computability press isbn 0262680521
rosser 1939 informal exposition proofs godels theorem churchs theorem journal symbolic logic 53–60 doi1023072269059 jstor 2269059 reprinted undecidable 223ff herein rossers famous definition effective method method step precisely predetermined certain produce answer finite number steps machine solve problem human intervention beyond inserting question later reading answer 225–226 undecidable
santoslang christopher 2014 moral ecology approaches machine ethics rysewyk simon pontier matthijs machine medical ethics switzerland springer 111–127 doi10100797833190810838
scott michael 2009 programming language pragmatics morgan kaufmann publisherselsevier isbn 9780123745149
sipser michael 2006 introduction theory computation publishing company isbn 053494728x
sober elliott wilson david sloan 1998 unto others evolution psychology unselfish behavior cambridge harvard university press
stone harold 1972 introduction computer organization data structures 1972 mcgrawhill york isbn 0070617260 particular first chapter titled algorithms turing machines programs succinct informal definition sequence instructions obeyed robot called algorithm
tausworthe robert 1977 standardized development computer software part methods englewood cliffs prentice–hall isbn 0138421951
turing alan 1936–37 computable numbers application entscheidungsproblem proceedings london mathematical society series 230–265 doi101112plmss2421230 corrections ibid 431937 544–546 reprinted undecidable 116ff turings famous paper completed masters dissertation kings college cambridge
turing alan 1939 systems logic based ordinals proceedings london mathematical society 161–228 doi101112plmss2451161 reprinted undecidable 155ff turings paper defined oracle thesis princeton
united states patent trademark office 2006 210602 mathematical algorithms 2100 patentability manual patent examining procedure mpep latest revision august 2006

secondary referencesedit

bolter david 1984 turings western culture computer 1984 university north carolina press chapel hill isbn 0807815640 isbn 0807841080
dilson jesse 2007 abacus 19681994 martins press isbn 031210409x isbn 031210409x
heijenoort jean 2001 frege gödel source book mathematical logic 1879–1931 1967 harvard university press cambridge isbn 0674324498 edition 1976 isbn 0674324498
hodges andrew 1983 alan turing enigma york simon schuster isbn 0671492071 isbn 0671492071 chapter spirit truth history leading discussion proof


readingedit


jean chabert 1999 history algorithms pebble microchip springer verlag isbn 9783540633693
algorithmics spirit computing addisonwesley 2004 isbn 9780321117847
knuth donald 2000 selected papers analysis algorithms stanford california center study language information
knuth donald 2010 selected papers design algorithms stanford california center study language information
berlinski david 2001 advent algorithm 300year journey idea computer harvest books isbn 9780156013918
thomas cormen charles leiserson ronald rivest clifford stein 2009 introduction algorithms third edition press isbn 9780262033848


external linksedit



look algorithm wiktionary free dictionary





wikibooks book topic algorithms





wikiversity learn teach others algorithm department algorithm



hazewinkel michiel 2001 1994 algorithm encyclopedia mathematics springer sciencebusiness media kluwer academic publishers isbn 9781556080104
algorithms curlie based dmoz
weisstein eric algorithm mathworld
dictionary algorithms data structures—national institute standards technology
algorithms data structures nikolai bezroukov


algorithm repositories


opengenus cosmos largest crowdsourced algorithm repository—opengenus foundation
stony brook algorithm repository—state university york stony brook
netlib repository—university tennessee ridge national laboratory
collected algorithms acm—association computing machinery
stanford graphbase—stanford university
combinatorica—university iowa state university york stony brook
library efficient datastructures algorithms leda—previously maxplanckinstitut informatik


lecture notes


algorithms course materials jeff erickson university illinois




authority control



lccn sh85003487
40011835
cb119358199 data
00560337
xx527980











retrieved httpsenwikipediaorgwindexphptitlealgorithmoldid817395646 categories algorithmsmathematical logictheoretical computer sciencehidden categories webarchive template wayback linksuse dates september 2017articles haudio microformatsarticles including recorded pronunciations englisharticles containing persianlanguage textall articles specifically marked weaselworded phrasesarticles specifically marked weaselworded phrases march 2017articles dmoz linkswikipedia articles lccn identifierswikipedia articles identifierswikipedia articles identifiersarticles example pseudocode
